using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using AI;
using Rules;

public class GameManager : MonoBehaviour
{
    [Header("References")] [SerializeField]
    private State state;

    [SerializeField] private RuleManager ruleManager;
    [SerializeField] private CardDrawHandler cardDrawHandler;
    [SerializeField] private PlayerHandHandler playerHandHandler;
    [SerializeField] private AIPlayer aiPlayer;

    [Header("Game State")] [SerializeField]
    public bool isPlayerTurn = true;

    [SerializeField] private float currentTurnTime = 0f;

    private bool gameStarted = false;

    void Start()
    {
        if (state == null) state = FindObjectOfType<State>();
        if (ruleManager == null) ruleManager = FindObjectOfType<RuleManager>();
        if (cardDrawHandler == null) cardDrawHandler = FindObjectOfType<CardDrawHandler>();
        if (playerHandHandler == null) playerHandHandler = FindObjectOfType<PlayerHandHandler>();

        StartGame();
    }

    void Update()
    {
        if (!gameStarted) return;

        // Handle turn timer
        if (state.turnTimeLimit > 0f)
        {
            currentTurnTime += Time.deltaTime;
            if (currentTurnTime >= state.turnTimeLimit)
            {
                Debug.Log("Turn time limit reached! Ending turn.");
                EndTurn();
            }
        }
    }

    public void StartGame()
    {
        Debug.Log("Starting new game...");

        // Rules are already generated by RuleManager.Start()
        // Draw starting hand based on setup rule
        StartCoroutine(DrawStartingHand());

        gameStarted = true;
        StartTurn();
    }

    private IEnumerator DrawStartingHand()
    {
        int startingCards = state.startingHandSize;
        Debug.Log($"Drawing {startingCards} starting cards");

        for (int i = 0; i < startingCards; i++)
        {
            DrawCard();
            yield return new WaitForSeconds(0.1f); // Visual delay
        }
    }

    public void StartTurn()
    {
        Debug.Log("=== Starting Turn ===");
        // Draw cards based on rules
        DrawCardsForTurn();

        currentTurnTime = 0f;
        state.ResetTurn();

        if (!isPlayerTurn && aiPlayer != null)
        {
            StartCoroutine(TriggerAITurnWithDelay());
        }
    }

    public void EndTurn()
    {
        Debug.Log("=== Ending Turn ===");

        // Resolve played cards
        ResolvePlayedCards();

        // Check win condition
        if (CheckWinCondition())
        {
            return; // Game over
        }

        state.actionsThisTurn = 0;

        // Start next turn
        isPlayerTurn = !isPlayerTurn;
        StartTurn();
    }

    private IEnumerator TriggerAITurnWithDelay()
    {
        yield return new WaitForSeconds(0.5f); // Brief delay before AI acts
        aiPlayer.TakeTurn();
    }

    private void DrawCardsForTurn()
    {
        int cardsToDraw = state.cardsDrawnPerTurn;
        Debug.Log($"Drawing {cardsToDraw} card(s) for turn");

        for (int i = 0; i < cardsToDraw; i++)
        {
            DrawCard(isPlayerTurn);
        }
    }

    public void DrawCard(bool forPlayer = true)
    {
        if (state.playerCards.Count >= state.maxHandSize)
        {
            Debug.Log("Hand is full!");
            return;
        }

        cardDrawHandler.DrawCard(forPlayer);
    }

    public bool CanPlayCard()
    {
        return state.CanPlayMoreCards();
    }

    public void OnCardPlayed(Sprite cardSprite)
    {
        if (!CanPlayCard())
        {
            Debug.Log("Cannot play more cards this turn!");
            return;
        }

        state.PlayCard(cardSprite);
        Debug.Log($"Card played: {cardSprite.name}. Cards played this turn: {state.actionsThisTurn}");
    }

    private void ResolvePlayedCards()
    {
        List<Sprite> cardsToResolve = isPlayerTurn ? state.playedCards : state.opponentPlayedCards;

        if (cardsToResolve.Count == 0)
        {
            Debug.Log("No cards played this turn");
            return;
        }

        Debug.Log($"Resolving {cardsToResolve.Count} {(isPlayerTurn ? "player" : "AI")} cards...");

        var setupRule = ruleManager.GetSetupRule();

        if (setupRule is BattleModeSetup battleMode)
        {
            ResolveBattleMode(battleMode, cardsToResolve);
        }
        else if (setupRule is PointRaceModeSetup pointRace)
        {
            ResolvePointRace(pointRace, cardsToResolve);
        }

        // Move played cards to discard
        foreach (var card in cardsToResolve)
        {
            state.discardPile.Add(card);
        }
        cardsToResolve.Clear();
    }

    private void ResolveBattleMode(BattleModeSetup battleMode, List<Sprite> cardsToResolve)
    {
        Debug.Log($"Resolving Battle Mode for {(isPlayerTurn ? "Player" : "AI")}...");

        int totalDamage = 0;
        int totalHealing = 0;
        bool hasBlankCard = false;

        foreach (var card in cardsToResolve)
        {
            if (battleMode.IsAce(card))
            {
                totalHealing += 2;
                Debug.Log($"{card.name} heals 2 life");
            }
            else if (battleMode.IsBlankCard(card))
            {
                hasBlankCard = true;
                Debug.Log($"{card.name} is a blank card - will reflect damage!");
            }
            else
            {
                int damage = battleMode.CalculateCardDamage(card);
                totalDamage += damage;
                Debug.Log($"{card.name} deals {damage} damage");
            }
        }

        // Apply healing and damage based on whose turn it is
        if (isPlayerTurn)
        {
            state.playerLife += totalHealing;
            if (hasBlankCard)
            {
                state.playerLife -= totalDamage;
                Debug.Log($"Player's damage reflected! Takes {totalDamage} damage. Life: {state.playerLife}");
            }
            else
            {
                state.opponentLife -= totalDamage;
                Debug.Log($"Player dealt {totalDamage} damage. Opponent life: {state.opponentLife}");
            }
        }
        else
        {
            state.opponentLife += totalHealing;
            if (hasBlankCard)
            {
                state.opponentLife -= totalDamage;
                Debug.Log($"AI's damage reflected! Takes {totalDamage} damage. Life: {state.opponentLife}");
            }
            else
            {
                state.playerLife -= totalDamage;
                Debug.Log($"AI dealt {totalDamage} damage. Player life: {state.playerLife}");
            }
        }
    }

    private void ResolvePointRace(PointRaceModeSetup pointRace, List<Sprite> cardsToResolve)
    {
        Debug.Log($"Resolving Point Race for {(isPlayerTurn ? "Player" : "AI")}...");

        int points = pointRace.CalculatePoints(cardsToResolve);

        if (isPlayerTurn)
        {
            state.playerPoints += points;
            Debug.Log($"Player earned {points} points! Total: {state.playerPoints}/{state.pointsToWin}");
        }
        else
        {
            state.opponentPoints += points;
            Debug.Log($"AI earned {points} points! Total: {state.opponentPoints}/{state.pointsToWin}");
        }
    }

    private bool CheckWinCondition()
    {
        if (state.winConditionType == State.WinConditionType.LastManStanding)
        {
            if (state.playerLife <= 0)
            {
                Debug.Log("GAME OVER - You lost!");
                GameOver(false);
                return true;
            }
            else if (state.opponentLife <= 0)
            {
                Debug.Log("VICTORY - You won!");
                GameOver(true);
                return true;
            }
        }
        else if (state.winConditionType == State.WinConditionType.FirstToPoints)
        {
            if (state.playerPoints >= state.pointsToWin)
            {
                Debug.Log("VICTORY - You reached the point goal!");
                GameOver(true);
                return true;
            }
            else if (state.opponentPoints >= state.pointsToWin)
            {
                Debug.Log("GAME OVER - Opponent reached the point goal first!");
                GameOver(false);
                return true;
            }
        }

        return false;
    }

    private void GameOver(bool playerWon)
    {
        gameStarted = false;
        Debug.Log("===================");
        Debug.Log(playerWon ? "PLAYER WINS!" : "PLAYER LOSES!");
        Debug.Log("===================");

        // You can add UI or restart logic here
    }

    public void RestartGame()
    {
        state.ResetGameState();
        ruleManager.GenerateRuleSet();
        StartGame();
    }
}